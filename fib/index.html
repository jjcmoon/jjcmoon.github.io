<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Jaron Maene</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="canonical" href="http://maene.dev" />
  <link rel="stylesheet" href="../style.css">
</head>


<body>
  <p style="text-align:left;">
    <a href="../index.html">Home</a>
    <span style="float:right;color:gray;">
        Written January 16, 2020
    </span>
</p>

<h1>Calculating Fibonacci, a complex(ity) story</h1>
<p>The Fibonacci series is so well-known, that introducing it seems
almost redundant. But for good measure, it’s the series based on the
recurrence relation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_n = F_{n-1} + F_{n-2}</annotation></semantics></math></p>
<p>With initial elements
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F_0 = 0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F_1 = 1</annotation></semantics></math>.<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> Implementing the Fibonacci function
seems very simple. It’s usually the second thing I try out when learning
new language, right after <code>"Hello world!"</code>. But this is a
deeper problem than it appears to be on the surface. In the rest of this
post, I’ll showcase different algorithms for calculating Fibonacci
numbers, in search of the algorithm with optimal complexity.</p>
<p>I encourage you to reflect on your own on what this (asymptotically)
fastest algorithm could be, before reading the rest of this article. You
may be surprised to find that a quick google (at time of writing) might
not help you! Wikipedia does not contain the result, and almost all of
the fora/blogs to pop up on the first google page have erroneous/lacking
answers.</p>
<h1 id="naive-solution">Naive solution</h1>
<p>Let’s start our quest with the most basic algorithm. In Python, we
can immediatly implement the recurrence as:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib1(n):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n<span class="op">==</span><span class="dv">0</span> <span class="kw">or</span> n<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fib1(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib1(n<span class="op">-</span><span class="dv">2</span>)</span></code></pre></div>
<p>This solution is very elegant, but not very efficient. How
inefficient you say? Well, recursion often makes it hard to see the
exact time complexity. What you can see, is the recurrence relation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T(n) = T(n-1) + T(n-2) + O(1) </annotation></semantics></math></p>
<p>Notice how this is almost the same recurrence relation as the
Fibonacci series itself! With bit of work, you can confirm this
intuition by showing that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T(n) = O(F_n)</annotation></semantics></math>.
As will be discussed later, Fibonacci is roughly exponential (to be
exact, it’s of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>ϕ</mi><mi>n</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(F_n) = O(\phi ^ n)</annotation></semantics></math>),
confirming that this is a pretty horrible implementation speed-wise.</p>
<h1 id="linear-time">Linear time</h1>
<p>A more sensible approach would be to use an imperative loop instead
of recursion.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib2(n):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    acc1 <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    acc2 <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        acc1, acc2 <span class="op">=</span> acc2, acc1<span class="op">+</span>acc2</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> acc1</span></code></pre></div>
<p>Another way of seeing this is that we are applying dynamic
programming: the last 2 results are memorized.</p>
<p>You can also get the same effect by staying functional and using
extra parameters instead of extra variables.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib3(n):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fib_aux(n, acc1, acc2):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> acc1</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fib_aux(n<span class="op">-</span><span class="dv">1</span>,acc2,acc1<span class="op">+</span>acc2)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fib_aux(n, <span class="dv">0</span>, <span class="dv">1</span>)</span></code></pre></div>
<p>It should be clear that both <code>fib2</code> and <code>fib3</code>
are of linear time complexity, a great improvement on <code>fib1</code>.
In practice <code>fib3</code> will be slower than <code>fib2</code>. As
Python does not have tail-recursion, <code>fib3</code> creates an extra
stack frame each loop. In other words, the memory usage of
<code>fib3</code> will be linear, while <code>fib2</code> has constant
memory usage. Note that other (functional) languages do optimize
tail-call recursion. In these languages <code>fib2</code> and
<code>fib3</code> should behave practically the same.</p>
<h1 id="sublinear-time">Sublinear time</h1>
<p>While the implementation above probably suffices for most practical
purposes, the question remains if we can do better.</p>
<p>It has long been known that there is a direct formula for the
Fibonacci sequence:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><mfrac><mrow><msup><mi>ϕ</mi><mi>n</mi></msup><mo>−</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>ϕ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup></mrow><msqrt><mn>5</mn></msqrt></mfrac></mrow><annotation encoding="application/x-tex"> F_n =  \frac{\phi^n - (1-\phi)^n}{\sqrt{5}}</annotation></semantics></math></p>
<p>Where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>
is <a href="https://en.wikipedia.org/wiki/Golden_ratio"
title="Wikipedia">the golden ratio</a>. This is known as Binet’s formula
<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>. How to derive this isn’t super
relevant here, but it’s discussed briefly in <a href="#derivation">the
appendix</a> if you’re interested.</p>
<p>This should be easy to implement in Python:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sqrt(n): </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n<span class="op">**</span><span class="fl">.5</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>phi <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> sqrt(<span class="dv">5</span>)) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib4(n):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (phi<span class="op">**</span>n <span class="op">-</span> (<span class="dv">1</span><span class="op">-</span>phi)<span class="op">**</span>n) <span class="op">/</span> sqrt(<span class="dv">5</span>)</span></code></pre></div>
<p>Alas, we forgot an important detail. Computers work in finite
precision. For large
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
the rounding errors can become very big. This means <code>fib4</code> is
only usable to get an approximation of the result, which is not what
we’re interested in. There are ways to fix this (<a
href="#calculation">see appendix</a>), but their performance is usually
not great either. Seems like we’ll need to try out something else…</p>
<p>Let’s back up and review how the <code>fib3</code> works. At each
call, the function has the parameters (n,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>n</mi></msub><annotation encoding="application/x-tex">F_n</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">F_{n+1}</annotation></semantics></math>).
All the auxiliary function does is turn (n,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>n</mi></msub><annotation encoding="application/x-tex">F_n</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">F_{n+1}</annotation></semantics></math>)
to (n,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">F_{n+1}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_n + F_{n+1}</annotation></semantics></math>).
We can reframe this to the following matrix notation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
 \begin{pmatrix}
  F_{n+2} \\
  F_{n+1} \\
 \end{pmatrix}
 =  
  \begin{pmatrix}
  1 &amp; 1 \\
  1 &amp; 0 \\
 \end{pmatrix}
 \cdot
 \begin{pmatrix}
  F_{n+1} \\
  F_{n} \\
 \end{pmatrix}
</annotation></semantics></math></p>
<p>This is a sensible thing to do for 2 reasons. First of all, by
framing the problem in a linear algebra background, we may be able to
use prior background knowledge we have in this field. Secondly, this
removes the annoying part where the next state relies on the previous 2
states. Here, it is possible to calculate the next term, just using the
last vector.</p>
<p>Because of this last fact, it is easy to obtain a closed formula:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup><mo>⋅</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
 \begin{pmatrix}
  F_{n+1} \\
  F_{n} \\
 \end{pmatrix}
 =  
  \begin{pmatrix}
  1 &amp; 1 \\
  1 &amp; 0 \\
 \end{pmatrix}^{n}
 \cdot
 \begin{pmatrix}
  F_{1} \\
  F_{0} \\
 \end{pmatrix}
</annotation></semantics></math></p>
<p>After filling in the initial conditions, you can show that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
  \begin{pmatrix}
  1 &amp; 1 \\
  1 &amp; 0 \\
 \end{pmatrix}^{n}
 =
  \begin{pmatrix}
  F_{n+1} &amp; F_{n} \\
  F_n &amp; F_{n-1} \\
 \end{pmatrix}
</annotation></semantics></math></p>
<p>So now our problem is reduced to quickly computing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup><annotation encoding="application/x-tex">\begin{pmatrix}  1 &amp; 1 \\  1 &amp; 0 \\  \end{pmatrix}^{n}</annotation></semantics></math>.</p>
<p>Doing this the naive way reduces to the same algorithm of
<code>fib2</code>. But you can speed up exponentiation by taking
advantage of the fact that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mn>2</mn><mi>n</mi></mrow></msup><mo>=</mo><msup><mi>x</mi><mi>n</mi></msup><mo>⋅</mo><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^{2n} = x^n \cdot x^n</annotation></semantics></math>
instead of using the naive
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>=</mo><mi>x</mi><mo>⋅</mo><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^{n+1} = x \cdot x^n</annotation></semantics></math>.</p>
<p>Note that this is an application of the divide and conquer strategy.
What follows is a simple Python implementation of this idea:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># we represent the matrix as a 4-tuple:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"># multiplication of matrices</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mult_matrix(A,B):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    (a,b,c,d) <span class="op">=</span> A</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    (e,f,g,h) <span class="op">=</span> B</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> a<span class="op">*</span>e <span class="op">+</span> b<span class="op">*</span>g</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> a<span class="op">*</span>f <span class="op">+</span> b<span class="op">*</span>h</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> c<span class="op">*</span>e <span class="op">+</span> d<span class="op">*</span>g</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> c<span class="op">*</span>f <span class="op">+</span> d<span class="op">*</span>h</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (u,w,x,y)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib5(n):</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fib5b(n):</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Returns X^n</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> n<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mult_matrix(X,fib5b(n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>            A <span class="op">=</span> fib5b(n<span class="op">//</span><span class="dv">2</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mult_matrix(A,A)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fib5b(n)[<span class="dv">1</span>]</span></code></pre></div>
<p>We can further shave off some computations by extracting exact
formulas from the matrix algorithm. Start by using the halving
trick:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>2</mn><mi>n</mi></mrow></msup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
  \begin{pmatrix}
  1 &amp; 1 \\
  1 &amp; 0 \\
 \end{pmatrix}^{2n}
 =
  \left(\begin{pmatrix}
  1 &amp; 1 \\
  1 &amp; 0 \\
 \end{pmatrix}^n\right)^2
</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
  \begin{pmatrix}
  F_{2n+1} &amp; F_{2n} \\
  F_{2n} &amp; F_{2n-1} \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  F_{n+1} &amp; F_n \\
  F_n &amp; F_{n-1} \\
 \end{pmatrix}^2
</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msubsup><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></msubsup></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
  \begin{pmatrix}
  F_{2n+1} &amp; F_{2n} \\
  F_{2n} &amp; F_{2n-1} \\
 \end{pmatrix}
 =
  \begin{pmatrix}
  F_{n+1}^2 + F_n^2 &amp; F_n (F_{n-1} + F_{n+1}) \\
  F_n (F_{n-1} + F_{n+1}) &amp; F_{n}^2 + F_{n-1}^2 \\
 \end{pmatrix}
</annotation></semantics></math></p>
<p>Now we have exact formulas for the even and odd cases!</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub><mo>=</mo><msub><mi>F</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>F</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>F</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> F_{2n} = F_n (F_{n-1} + F_{n+1}) = F_n (2F_{n+1} - F_n) </annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msubsup><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex"> F_{2n+1} = F_{n+1}^2 + F_n^2 </annotation></semantics></math></p>
<p>We can condense these ideas in the following (fairly elegant)
algorithm:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib6(n):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># [3:] because the first 2 digits are &quot;0b&quot; + to skip the first iteration</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bit <span class="kw">in</span> <span class="bu">bin</span>(n)[<span class="dv">3</span>:]:</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> a<span class="op">*</span>(<span class="dv">2</span><span class="op">*</span>b <span class="op">-</span> a) , a<span class="op">*</span>a <span class="op">+</span> b<span class="op">*</span>b</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># in the odd case add a single iteration</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> bit <span class="op">==</span> <span class="st">&#39;1&#39;</span>:</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            a, b <span class="op">=</span> b, a<span class="op">+</span>b</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a</span></code></pre></div>
<p>The time complexity of the above function is linear in the number of
digits, so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log(n))</annotation></semantics></math>.
A significant improvement on <code>fib2</code>!</p>
<p>The above algorithm is similar to what is used in actual
high-performance code, such as the legendary <a
href="https://gmplib.org/" title="GMP Homepage">GMP</a>. Although they
do apply a little further optimization. For example, the above version
uses 3 multiplications in each call, but it is possible to use only 2.
(Note that the <code>2*b</code> is not counted as a multiplication, as
it’s done with bit shifting in practice).</p>
<p><em>Warning, lots of math ahead. You can skip to the <a
href="#Evaluating">next section</a>.</em></p>
<p>It’s already known that:<br />
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub><mo>=</mo><msub><mi>F</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>F</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> F_{2n} = F_n (2F_{n+1} - F_n) </annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msubsup><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex"> F_{2n+1} = F_{n+1}^2 + F_n^2 </annotation></semantics></math></p>
<p>The second formula is straightforward, but the first one is a bit
more awkward. It would be easier if it was also expressed in terms of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">F_{n+1}^2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">F_n^2</annotation></semantics></math>.
Rearranging the above formula:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub><mo>=</mo><mn>2</mn><msub><mi>F</mi><mi>n</mi></msub><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex"> F_{2n} = 2F_n F_{n+1} - F_n^2 </annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">F_n^2</annotation></semantics></math>
is already here, we can get
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">F_{n+1}^2</annotation></semantics></math>
by doing:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub><mo>=</mo><mn>2</mn><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex"> F_{2n} = 2(F_{n+1} - F_{n-1}) F_{n+1} - F_n^2 </annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub><mo>=</mo><mn>2</mn><msubsup><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>−</mo><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup><mo>−</mo><mn>2</mn><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex"> F_{2n} = 2F_{n+1}^2 - F_n^2 - 2F_{n-1} F_{n+1} </annotation></semantics></math></p>
<p>Now the remaining problem is getting rid of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_{n-1} F_{n+1}</annotation></semantics></math>
term. The trick to doing this is realizing that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">∣</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">∣</mo></mrow><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">
\begin{vmatrix}
  F_{n+1} &amp; F_{n} \\
  F_n &amp; F_{n-1}
\end{vmatrix}
 = F_{n+1} F_{n-1} - F_{n}^2
</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">∣</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mi>n</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">∣</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">∣</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">∣</mo></mrow><mi>n</mi></msup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">
  \begin{vmatrix}
  F_{n+1} &amp; F_{n} \\
  F_n &amp; F_{n-1}
 \end{vmatrix}
 =
\begin{vmatrix}
  1 &amp; 1 \\
  1 &amp; 0
\end{vmatrix}^n
 = (-1)^n
</annotation></semantics></math></p>
<p>Implying that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">F_{n-1}F_{n+1} + F_n^2 = (-1)^n</annotation></semantics></math>.
This is known as Cassini’s identity.</p>
<p>Using this, we arrive at:<br />
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub><mo>=</mo><mn>2</mn><msubsup><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>−</mo><mn>3</mn><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup><mo>−</mo><mn>2</mn><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup></mrow><annotation encoding="application/x-tex"> F_{2n} = 2F_{n+1}^2 - 3F_n^2 - 2(-1)^n </annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msubsup><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>F</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex"> F_{2n+1} = F_{n+1}^2 + F_n^2 </annotation></semantics></math></p>
<p>Clearly evaluating these relations needs only two squares, an
improvement on the previous 3 multiplications.</p>
<p><a name="Evaluating"></a></p>
<h1 id="evaluating">Evaluating</h1>
<p>So far the theory. Let’s plot some graphs to see if it actually
worked.</p>
<p>Starting off with the first three implementations, remember that
<code>fib1</code> was the naive implementation with exponential time
complexity, while <code>fib2</code> and <code>fib3</code> had linear
complexity.</p>
<p><img src="../assets/fib/output_15_1.png" /></p>
<p>As to be expected, <code>fib1</code>’s runtime explodes, while the
other 2 remain virtually constant. Now let’s see if the added complexity
of <code>fib5</code> and <code>fib6</code> are worth it:</p>
<p><img src="../assets/fib/output_19_1.png" /></p>
<p>It was, <code>fib2</code> is way slower. Note that <code>fib3</code>
is not included here. Because of the maximum recursion depth of Python,
it doesn’t work on input larger than 2000 (although you could change
this barrier). Lastly, let’s review <code>fib5</code> and
<code>fib6</code> on larger data:</p>
<p><img src="../assets/fib/output_21_1.png" /></p>
<p>Wait, didn’t I say that <code>fib5/6</code> were
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math>?
These do not look like logarithms at all, they appear to be superlinear!
What’s going on?</p>
<h1 id="digging-deeper">Digging deeper</h1>
<p>The flaw in our previous analysis is the implicit assumption that
addition and multiplication are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math>.
This is the case for 32-bit integers, as these operations are
implemented in hardware. But unlike Java or C, which use i32 integers,
python has arbitrary-size integers. This is obviously necessary to avoid
overflows
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mn>50</mn></msub><annotation encoding="application/x-tex">F_{50}</annotation></semantics></math>
is enough to overflow in i32), but also has a cost: addition and
multiplication no longer have constant time usage.</p>
<p>Addition of big integers is straightforward. It’s not unlike the
grade school method, you have an array of i32’s and add them from right
to left, taking the carries into account. As such the complexity is
linear in the amount of digits, so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log(n))</annotation></semantics></math>.
Multiplication fares worse, the naive algorithm is quadratic in the
number of digits:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log(n)^2)</annotation></semantics></math>.</p>
<p>Look at the last multiplication needed in <code>fib6</code>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>n</mi><mi>/</mi><mn>2</mn></mrow></msub><mo>⋅</mo><msub><mi>F</mi><mrow><mi>n</mi><mi>/</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_{n/2} \cdot F_{n/2}</annotation></semantics></math>.
This will have a time complexity of:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mrow><mi>n</mi><mi>/</mi><mn>2</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>ϕ</mi><mrow><mi>n</mi><mi>/</mi><mn>2</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log(F_{n/2})^2) = O(\log(\phi^{n/2})^2) = O(n^2)</annotation></semantics></math>.
This is far greater than the constant time assumed! By applying the <a
href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)"
title="Wikipedia">master’s theorem</a>, the complexity of the entire
algorithm becomes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>
instead of the assumed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log(n))</annotation></semantics></math>.</p>
<p>Note that the complexity of <code>fib2</code> (which was assumed
linear) is also of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>
when taking into account the real complexity of addition. Does this mean
the algorithms are asymptotically equivalent? Not really.</p>
<p>It was long assumed that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>
is the best possible algorithm for multiplication (here n is input size
in bits). Famously, the young Karatsuba didn’t believe his professor
(another famous Russian computer scientist: Kolmogorov) who proclaimed
this in a lecture. The result is the <a
href="https://en.wikipedia.org/wiki/Karatsuba_algorithm"
title="Wikipedia">Karatsuba algorithm</a>, which has complexity
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mrow><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mrow><mn>1</mn><mo>,</mo><mn>58</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^{\log(3)}) \approx O(n^{1,58})</annotation></semantics></math>,
a considerable improvement. The algorithm is based on a divide and
conquer approach, much like the Strassen algorithm for matrix
multiplication. Further research has resulted in several algorithms
which decreased the complexity further still. (But the ever-increasing
constant factors have limited practical usability).</p>
<p>Some may find it surprising to hear, that multiplying 2 numbers is
still an open research question. Just last year, a new algorithm was
proposed<a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>, that obtained the elusive limit of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n \log(n))</annotation></semantics></math>.
It has been conjectured that this is the best possible complexity, but
no proof has been found yet.</p>
<h1 id="conclusions">Conclusions</h1>
<p>Python is smart enough not to use naive multiplication for large
numbers. It uses the Karatsuba algorithm. So <code>fib6</code> has time
complexity
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mrow><mn>1</mn><mo>,</mo><mn>58</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^{1,58})</annotation></semantics></math>
(which is finally the correct answer).</p>
<p>The optimal complexity is still unknown, but
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n \log(n))</annotation></semantics></math>
seems likely. This is implied by the surprising fact that the complexity
of Fibonacci is equal to that of multiplication. This also means that
there is no more asymptotic improvement possible on the actual
recurrence relations.</p>
<p>I wondered if the recurrence relations are also optimal in practice
(i.e. in the number of multiplications). This seems likely but I have
found no proof. I’ll update this if I find one.</p>
<h1 id="references">References</h1>
<p>Some good further sources on this problem:</p>
<ul>
<li><a href="http://www.oranlooney.com/post/fibonacci/">Blog post by
Oran Looney</a>. Good article, digs into lots of the same things as
here, although it maybe doesn’t quite get as technical.</li>
<li><a
href="http://www.ii.uni.wroc.pl/~lorys/IPL/article75-6-1.pdf">Fast
Fibonacci algorithm for FFT-based multiplication</a></li>
<li><a href="https://www.nayuki.io/page/fast-fibonacci-algorithms">Blog
post by Nayuki</a>. Short and to-the-point overview of the most
important algorithms.</li>
<li><a href="https://blog.paulhankin.net/fibonacci2/">Blog post by Paul
Hanking</a>. Another excellent article. It takes an entirely different
approach, by using generating functions.</li>
<li>Algorithms for computing Fibonacci numbers quickly, by JL Holloway.
Master thesis, Comparing a lot of different algorithms.</li>
<li><a
href="https://gmplib.org/manual/Fibonacci-Numbers-Algorithm.html">Algorithm
used in GMP</a></li>
</ul>
<p><a name="derivation"></a></p>
<h1 id="appendix-1-derivation-of-binets-formula">Appendix 1: Derivation
of Binet’s formula</h1>
<p>We’ll derive the formula using difference equations (the discrete
equivalent of differential equations), but there are many other
approaches. The Fibonacci equation is linear (meaning every term is of
the form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>F</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo>+</mo><mi>b</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">aF[n+b]</annotation></semantics></math>
or constant), and homogeneous (no constant term). This makes it very
easy to solve. A thorough explanation would lead us too far, but
basically one solves this by converting to the characteristic
polynomial:<br />
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> x^2 - x - 1 = 0 </annotation></semantics></math>
This is obtained by substituting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo>+</mo><mi>c</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">F[n+c]</annotation></semantics></math>
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>x</mi><mi>c</mi></msup><annotation encoding="application/x-tex">x^c</annotation></semantics></math>.
Now, we find the roots:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>±</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex"> x = \frac{1 \pm \sqrt 5}{2} </annotation></semantics></math>
One might recognize this as the golden ratio:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\phi = \frac{1 + \sqrt 5}{2}</annotation></semantics></math>
So
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">x = \phi</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">1-\phi</annotation></semantics></math>.</p>
<p>Using this we can find the exact solution:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><msup><mi>ϕ</mi><mi>n</mi></msup><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>ϕ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup></mrow><annotation encoding="application/x-tex"> F[n] = c_1\phi^n + c_2(1-\phi)^n </annotation></semantics></math>
To find the constants
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mn>1</mn></msub><annotation encoding="application/x-tex">c_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mn>2</mn></msub><annotation encoding="application/x-tex">c_2</annotation></semantics></math>,
we only need to fill in the initial conditions.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>0</mn><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><msup><mi>ϕ</mi><mn>0</mn></msup><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>ϕ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>0</mn></msup></mrow><annotation encoding="application/x-tex"> F[0] = 0 = c_1\phi^0 + c_2(1-\phi)^0 </annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇔</mo><msub><mi>c</mi><mn>1</mn></msub><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> \Leftrightarrow c_1 + c_2 = 0  </annotation></semantics></math>
and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>1</mn><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><mi>ϕ</mi><mo>−</mo><msub><mi>c</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>ϕ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> F[1] = 1 = c_1\phi - c_1(1-\phi) </annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇔</mo><mn>1</mn><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>ϕ</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \Leftrightarrow 1 = c_1(2 \phi - 1) </annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇔</mo><msub><mi>c</mi><mn>1</mn></msub><mo>=</mo><mfrac><mn>1</mn><msqrt><mn>5</mn></msqrt></mfrac><mo>=</mo><mo>−</mo><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex"> \Leftrightarrow c_1 = \frac{1}{\sqrt{5}} = -c_2 </annotation></semantics></math></p>
<p>This brings us to the solution:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mfrac><mrow><msup><mi>ϕ</mi><mi>n</mi></msup><mo>−</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>ϕ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup></mrow><msqrt><mn>5</mn></msqrt></mfrac></mrow><annotation encoding="application/x-tex"> F[n] =  \frac{\phi^n - (1-\phi)^n}{\sqrt{5}}</annotation></semantics></math></p>
<p>Another way of deriving the formula is using the matrix
representation. When a matrix is symmetric (like in our case), you can
compute the eigendecomposition and find the explicit formula from there.
This is explored more in detail in this <a
href="http://www.oranlooney.com/post/fibonacci/">blog post by Oran
Looney</a>.</p>
<p>On a side note, this connection holds in general, linear
recurrence/difference relations are just other representations of
matrices. As such, the roots of the characteristic polynomial will be
eigenvalues of the matrix.</p>
<p><a name="calculation"></a></p>
<h1 id="appendix-2-calculation-of-binets-formula">Appendix 2:
Calculation of Binet’s formula</h1>
<p>The first thing you could try is using arbitrary-precision
floating-point arithmetic (e.g. using <a
href="https://en.wikipedia.org/wiki/GNU_MPFR"
title="Wikipedia">MPFR</a>). This is an easy solution to the problem,
but sadly also a pretty slow one.</p>
<p>A much more clever method is working in exact arithmetic. So you can
represent a number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">a + b\phi</annotation></semantics></math>
as a tuple (a,b). This works as multiplying will again give you a number
of this form, because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ϕ</mi><mn>2</mn></msup><mo>=</mo><mn>1</mn><mo>+</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi^2 = 1+\phi</annotation></semantics></math>.
In mathematical jargon, we say that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐐</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>ϕ</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Q}[\phi]</annotation></semantics></math>
is closed under addition and multiplication (which is all we need to
calculate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ϕ</mi><mi>n</mi></msup><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>ϕ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\phi^n + (1-\phi)^n</annotation></semantics></math>).
For an implementation of this idea (where I stole the idea), see <a
href="http://bit.ly/ruby_binet" title="Github">here</a>.</p>
<p>Note that, when you work out the above solution, the algorithm will
be similar to the matrix solution. Indeed, you can similarly use the
same divide-and-conquer exponentiation, to get the same complexity. I
suppose you could also extract the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub><annotation encoding="application/x-tex">F_{2n}</annotation></semantics></math>
identities by following this route but haven’t tried it out myself.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GoldenRational:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, a, b):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.r <span class="op">=</span> a</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.g <span class="op">=</span> b</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__add__</span>(<span class="va">self</span>, other):</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> GoldenRational(<span class="va">self</span>.r<span class="op">+</span>other.r, <span class="va">self</span>.g<span class="op">+</span>other.g)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__sub__</span>(<span class="va">self</span>, other):</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> GoldenRational(<span class="va">self</span>.r<span class="op">-</span>other.r, <span class="va">self</span>.g<span class="op">-</span>other.g)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__neg__</span>(<span class="va">self</span>):</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> GoldenRational(<span class="op">-</span><span class="va">self</span>.r, <span class="op">-</span><span class="va">self</span>.g)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__mul__</span>(<span class="va">self</span>, other):</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> <span class="va">self</span>.<span class="bu">tuple</span>()</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        c, d <span class="op">=</span> other.<span class="bu">tuple</span>()</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> GoldenRational(a<span class="op">*</span>c <span class="op">+</span> b<span class="op">*</span>d, d<span class="op">*</span>(a<span class="op">+</span>b) <span class="op">+</span> b<span class="op">*</span>c)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__pow__</span>(<span class="va">self</span>, exp):</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="bu">type</span>(exp)<span class="op">==</span><span class="bu">int</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> exp <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> GoldenRational(<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> exp<span class="op">%</span><span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span> <span class="op">*</span> <span class="va">self</span><span class="op">**</span>(exp<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> <span class="va">self</span><span class="op">**</span>(exp<span class="op">//</span><span class="dv">2</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> t<span class="op">*</span>t</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;</span><span class="sc">{}</span><span class="st"> + </span><span class="sc">{}</span><span class="st">*phi&quot;</span>.<span class="bu">format</span>(<span class="op">*</span><span class="va">self</span>.<span class="bu">tuple</span>())</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;GoldenRational(</span><span class="sc">{}</span><span class="st">,</span><span class="sc">{}</span><span class="st">)&quot;</span>.<span class="bu">format</span>(<span class="va">self</span>.r, <span class="va">self</span>.g)</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">tuple</span>(<span class="va">self</span>):</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.r, <span class="va">self</span>.g</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>PHI <span class="op">=</span> GoldenRational(<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>SQRT5 <span class="op">=</span> GoldenRational(<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>ONE <span class="op">=</span> GoldenRational(<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib8(n):</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>(PHI<span class="op">**</span>n).r <span class="op">+</span> ((ONE<span class="op">-</span>PHI)<span class="op">**</span>n).r</span></code></pre></div>
<h1 id="footnotes">Footnotes</h1>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Other choices are possible of course,
e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">F_0=2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F_0=1</annotation></semantics></math>
are known as the <a href="https://en.wikipedia.org/wiki/Lucas_number"
title="Wikipedia">Lucas numbers</a>.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Binet wasn’t the first to invent the formula. It was
already known a century earlier by the French mathematician Abraham de
Moivre (a friend of Newton).<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a
href="https://hal.archives-ouvertes.fr/hal-02070778/document">Integer
multiplication in time O(n log n), by David Harvey and Joris van der
Hoeven</a><a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

</body>
</html>